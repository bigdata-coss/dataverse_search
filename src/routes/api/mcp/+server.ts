/**
 * Dataverse MCP Server API Endpoint
 * Í∏∞Ï°¥ Í≤ÄÏÉâ APIÎ•º ÌôúÏö©ÌïòÎäî MCP ÏÑúÎ≤Ñ
 */

import type { RequestHandler } from '@sveltejs/kit';
import { json } from '@sveltejs/kit';
import { getActiveInstances, getInstancesByCountry, getInstanceStats } from '$lib/data/dataverse-instances.js';
import { dev } from '$app/environment';

// MCP ÏÑúÎ≤Ñ ÏÑ§Ï†ï
const MCP_SERVER_NAME = 'global-dataverse-mcp';
const MCP_SERVER_VERSION = '2.0.0';
const MCP_SERVER_DESCRIPTION = 'AI-powered global Dataverse search and analysis platform';

/**
 * Í∏∞Ï°¥ API Í≤ÄÏÉâ Í≤∞Í≥ºÎ•º MCP ÌòïÌÉúÎ°ú Ìè¨Îß∑ÌåÖ
 */
function formatSearchResultsForMCP(data: any, query: string, searchType: string): string {
	if (!data.success || !data.results || data.results.length === 0) {
		return `üîç "${query}" Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.\n\nüí° Îã§Î•∏ ÌÇ§ÏõåÎìúÎ•º ÏãúÎèÑÌï¥Î≥¥ÏÑ∏Ïöî.`;
	}

	let resultText = `üîç ${searchType} Í≤ÄÏÉâ Í≤∞Í≥º\n`;
	resultText += `=====================\n`;
	resultText += `Í≤ÄÏÉâÏñ¥: "${query}"\n`;
	resultText += `Ï¥ù Í≤∞Í≥º: ${data.total?.toLocaleString() || data.results.length}Í∞ú\n`;
	resultText += `ÌëúÏãú: ${data.results.length}Í∞ú\n\n`;

	data.results.forEach((item: any, index: number) => {
		resultText += `${index + 1}. **${item.title || item.name || 'Untitled'}**\n`;
		resultText += `   üè∑Ô∏è ÌÉÄÏûÖ: ${item.type || 'dataset'}\n`;
		
		if (item.authors && item.authors.length > 0) {
			resultText += `   üë§ Ï†ÄÏûê: ${item.authors.slice(0, 3).join(', ')}${item.authors.length > 3 ? '...' : ''}\n`;
		}
		
		if (item.published_at || item.publishedAt) {
			resultText += `   üìÖ Î∞úÌñâÏùº: ${new Date(item.published_at || item.publishedAt).getFullYear()}\n`;
		}
		
		if (item.description) {
			const desc = item.description.length > 150 
				? item.description.substring(0, 150) + '...' 
				: item.description;
			resultText += `   üìù ÏÑ§Î™Ö: ${desc}\n`;
		}
		
		if (item.instance) {
			resultText += `   üèõÔ∏è Ïù∏Ïä§ÌÑ¥Ïä§: ${item.instance}\n`;
		}
		
		if (item.url) {
			resultText += `   üåê URL: ${item.url}\n`;
		}
		
		resultText += `\n`;
	});

	// Í≤ÄÏÉâ Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
	if (data.searchStrategy) {
		resultText += `\nüéØ Í≤ÄÏÉâ Ï†ÑÎûµ: ${data.searchStrategy}\n`;
	}
	
	if (data.searchTime) {
		resultText += `‚è±Ô∏è Í≤ÄÏÉâ ÏãúÍ∞Ñ: ${(data.searchTime * 1000).toFixed(0)}ms\n`;
	}

	if (data.suggestions && data.suggestions.length > 0) {
		resultText += `\nüí° Ï∂îÍ∞Ä Í≤ÄÏÉâ Ï†úÏïà:\n`;
		data.suggestions.forEach((suggestion: string) => {
			resultText += `‚Ä¢ "${suggestion}"\n`;
		});
	}

	return resultText;
}

/**
 * GET ÏöîÏ≤≠ Ìï∏Îì§Îü¨ - MCP ÏÑúÎ≤Ñ Ï†ïÎ≥¥
 */
export const GET: RequestHandler = async () => {
	const stats = getInstanceStats();
	
	return json({
		name: MCP_SERVER_NAME,
		version: MCP_SERVER_VERSION,
		description: MCP_SERVER_DESCRIPTION,
		status: 'active',
		instances: {
			total: stats.total,
			active: stats.active,
			countries: stats.countriesCount
		},
		capabilities: ['search-datasets', 'search-global-dataverse', 'search-by-country', 'get-dataset-info', 'list-dataverse-instances'],
		endpoints: {
			mcp: '/api/mcp',
			search: '/api/mcp/search'
		}
	});
};

/**
 * POST ÏöîÏ≤≠ Ìï∏Îì§Îü¨ - MCP ÏÑúÎ≤Ñ ÏóîÎìúÌè¨Ïù∏Ìä∏
 */
export const POST: RequestHandler = async ({ request }) => {
	let body: any;
	
	try {
		body = await request.json();
		
		if (dev) {
			console.log('üîß [MCP] ÏàòÏã†Îêú ÏöîÏ≤≠:', JSON.stringify(body, null, 2));
		}
		
		// JSON-RPC 2.0 Ïä§Ìéô Í≤ÄÏ¶ù
		if (!body.jsonrpc || body.jsonrpc !== '2.0') {
			return json({
				jsonrpc: '2.0',
				id: body.id || null,
				error: {
					code: -32600,
					message: 'Invalid Request: missing or invalid jsonrpc field'
				}
			});
		}

		if (!body.method) {
			return json({
				jsonrpc: '2.0',
				id: body.id || null,
				error: {
					code: -32600,
					message: 'Invalid Request: missing method field'
				}
			});
		}

		// MCP ÌîÑÎ°úÌÜ†ÏΩú Î©îÏãúÏßÄ Ï≤òÎ¶¨
		switch (body.method) {
			case 'initialize': {
				const initializeResult = {
					protocolVersion: '2024-11-05',
					serverInfo: {
						name: MCP_SERVER_NAME,
						version: MCP_SERVER_VERSION
					},
					capabilities: {
						tools: {},
						resources: {},
						logging: {}
					}
				};

				if (dev) {
					console.log('üîß [MCP] Initialize ÏùëÎãµ:', JSON.stringify(initializeResult, null, 2));
				}

				return json({
					jsonrpc: '2.0',
					id: body.id,
					result: initializeResult
				});
			}

			case 'notifications/initialized': {
				// notificationsÎäî ÏùëÎãµÏù¥ ÌïÑÏöî ÏóÜÏùå
				return new Response(null, { status: 200 });
			}

			case 'tools/list': {
				const toolsListResult = {
					tools: [
						{
							name: 'search-datasets',
							description: 'DataverseÏóêÏÑú Îç∞Ïù¥ÌÑ∞ÏÖãÏùÑ Í≤ÄÏÉâÌï©ÎãàÎã§.',
							inputSchema: {
								type: 'object',
								properties: {
									query: {
										type: 'string',
										description: 'Í≤ÄÏÉâÌï† ÌÇ§ÏõåÎìúÎÇò Î¨∏Íµ¨'
									},
									instance_url: {
										type: 'string',
										format: 'uri',
										description: 'ÌäπÏ†ï Dataverse Ïù∏Ïä§ÌÑ¥Ïä§ URL'
									},
									type: {
										type: 'string',
										enum: ['dataset', 'file', 'dataverse'],
										description: 'Í≤ÄÏÉâ ÎåÄÏÉÅ ÌÉÄÏûÖ'
									},
									per_page: {
										type: 'number',
										minimum: 1,
										maximum: 100,
										default: 20,
										description: 'ÌéòÏù¥ÏßÄÎãπ Í≤∞Í≥º Ïàò'
									}
								},
								required: ['query']
							}
						},
						{
							name: 'search-global-dataverse',
							description: 'Ï†Ñ ÏÑ∏Í≥Ñ Î™®Îì† ÌôúÏÑ± Dataverse Ïù∏Ïä§ÌÑ¥Ïä§ÏóêÏÑú ÎèôÏãúÏóê Í≤ÄÏÉâÌï©ÎãàÎã§.',
							inputSchema: {
								type: 'object',
								properties: {
									query: {
										type: 'string',
										description: 'Í≤ÄÏÉâÌï† ÌÇ§ÏõåÎìúÎÇò Î¨∏Íµ¨'
									},
									type: {
										type: 'string',
										enum: ['dataset', 'file', 'dataverse'],
										description: 'Í≤ÄÏÉâ ÎåÄÏÉÅ ÌÉÄÏûÖ'
									},
									per_page: {
										type: 'number',
										minimum: 1,
										maximum: 50,
										default: 10,
										description: 'Ïù∏Ïä§ÌÑ¥Ïä§Îãπ Í≤∞Í≥º Ïàò'
									}
								},
								required: ['query']
							}
						},
						{
							name: 'search-by-country',
							description: 'ÌäπÏ†ï Íµ≠Í∞ÄÏùò Dataverse Ïù∏Ïä§ÌÑ¥Ïä§ÏóêÏÑúÎßå Í≤ÄÏÉâÌï©ÎãàÎã§.',
							inputSchema: {
								type: 'object',
								properties: {
									query: {
										type: 'string',
										description: 'Í≤ÄÏÉâÌï† ÌÇ§ÏõåÎìúÎÇò Î¨∏Íµ¨'
									},
									country: {
										type: 'string',
										description: 'Í≤ÄÏÉâÌï† Íµ≠Í∞ÄÎ™Ö (Ïòà: USA, South Korea, Germany)'
									},
									type: {
										type: 'string',
										enum: ['dataset', 'file', 'dataverse'],
										description: 'Í≤ÄÏÉâ ÎåÄÏÉÅ ÌÉÄÏûÖ'
									},
									per_page: {
										type: 'number',
										minimum: 1,
										maximum: 50,
										default: 10,
										description: 'Ïù∏Ïä§ÌÑ¥Ïä§Îãπ Í≤∞Í≥º Ïàò'
									}
								},
								required: ['query', 'country']
							}
						},
						{
							name: 'get-dataset-info',
							description: 'ÌäπÏ†ï Îç∞Ïù¥ÌÑ∞ÏÖãÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏ÏòµÎãàÎã§.',
							inputSchema: {
								type: 'object',
								properties: {
									persistent_id: {
										type: 'string',
										description: 'Îç∞Ïù¥ÌÑ∞ÏÖãÏùò DOI ÎòêÎäî Handle'
									},
									instance_url: {
										type: 'string',
										format: 'uri',
										description: 'Dataverse Ïù∏Ïä§ÌÑ¥Ïä§ URL'
									}
								},
								required: ['persistent_id']
							}
						},
						{
							name: 'list-dataverse-instances',
							description: 'ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Î™®Îì† Dataverse Ïù∏Ïä§ÌÑ¥Ïä§ Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏòµÎãàÎã§.',
							inputSchema: {
								type: 'object',
								properties: {
									country: {
										type: 'string',
										description: 'ÌäπÏ†ï Íµ≠Í∞ÄÎ°ú ÌïÑÌÑ∞ÎßÅ (ÏÑ†ÌÉùÏÇ¨Ìï≠)'
									}
								}
							}
						}
					]
				};

				return json({
					jsonrpc: '2.0',
					id: body.id,
					result: toolsListResult
				});
			}

			case 'tools/call': {
				const { name: toolName, arguments: toolArgs } = body.params || {};

				if (!toolName) {
					return json({
						jsonrpc: '2.0',
						id: body.id,
						error: {
							code: -32602,
							message: 'Invalid params: missing tool name'
						}
					});
				}

				// ÎèÑÍµ¨ Ïã§Ìñâ Î°úÏßÅ
				try {
					let toolResult: any;

					switch (toolName) {
						case 'search-datasets': {
							const { query, instance_url, type, per_page } = toolArgs || {};
							
							if (!query) {
								return json({
									jsonrpc: '2.0',
									id: body.id,
									error: {
										code: -32602,
										message: 'Invalid params: query is required'
									}
								});
							}

							// Í∏∞Ï°¥ API Ìò∏Ï∂úÎ°ú Î≥ÄÍ≤Ω
							const requestBody: any = {
								query,
								per_page: per_page || 20,
								start: 0,
								sort: 'date',
								order: 'desc',
								include_files: type === 'file'
							};

							// ÌäπÏ†ï Ïù∏Ïä§ÌÑ¥Ïä§ ÏßÄÏ†ï
							if (instance_url) {
								const instance = getActiveInstances().find(inst => inst.url === instance_url);
								if (instance) {
									requestBody.specific_instance = {
										id: instance.id,
										url: instance.url,
										apiUrl: instance.apiUrl,
										platformName: instance.platformName,
										country: instance.country,
										organization: instance.organization
									};
								}
							}

							const url = new URL(request.url);
							const apiUrl = `${url.origin}/api/mcp/search`;
							
							const response = await fetch(apiUrl, {
								method: 'POST',
								headers: {
									'Content-Type': 'application/json',
								},
								body: JSON.stringify(requestBody)
							});

							if (!response.ok) {
								throw new Error(`Search API error: ${response.status}`);
							}

							const data = await response.json();
							const formattedText = formatSearchResultsForMCP(data, query, `ÌäπÏ†ï Ïù∏Ïä§ÌÑ¥Ïä§ (${instance_url || 'Harvard Dataverse'})`);

							toolResult = {
								content: [{
									type: 'text',
									text: formattedText
								}]
							};
							break;
						}

						case 'search-global-dataverse': {
							const { query, type, per_page } = toolArgs || {};
							
							if (!query) {
								return json({
									jsonrpc: '2.0',
									id: body.id,
									error: {
										code: -32602,
										message: 'Invalid params: query is required'
									}
								});
							}

							// Í∏∞Ï°¥ API Ìò∏Ï∂úÎ°ú Î≥ÄÍ≤Ω (Ï†ÑÏó≠ Í≤ÄÏÉâ)
							const requestBody: any = {
								query,
								per_page: per_page || 10,
								start: 0,
								sort: 'date',
								order: 'desc',
								include_files: type === 'file'
								// countryÎ•º ÏßÄÏ†ïÌïòÏßÄ ÏïäÏúºÎ©¥ Ï†ÑÏó≠ Í≤ÄÏÉâ
							};

							const url = new URL(request.url);
							const apiUrl = `${url.origin}/api/mcp/search`;
							
							const response = await fetch(apiUrl, {
								method: 'POST',
								headers: {
									'Content-Type': 'application/json',
								},
								body: JSON.stringify(requestBody)
							});

							if (!response.ok) {
								throw new Error(`Search API error: ${response.status}`);
							}

							const data = await response.json();
							const formattedText = formatSearchResultsForMCP(data, query, 'Ï†ÑÏó≠ Í≤ÄÏÉâ');

							toolResult = {
								content: [{
									type: 'text',
									text: formattedText
								}]
							};
							break;
						}

						case 'search-by-country': {
							const { query, country, type, per_page } = toolArgs || {};
							
							if (!query || !country) {
								return json({
									jsonrpc: '2.0',
									id: body.id,
									error: {
										code: -32602,
										message: 'Invalid params: query and country are required'
									}
								});
							}

							// Í∏∞Ï°¥ API Ìò∏Ï∂úÎ°ú Î≥ÄÍ≤Ω (Íµ≠Í∞ÄÎ≥Ñ Í≤ÄÏÉâ)
							const requestBody: any = {
								query,
								country,
								per_page: per_page || 10,
								start: 0,
								sort: 'date',
								order: 'desc',
								include_files: type === 'file'
							};

							const url = new URL(request.url);
							const apiUrl = `${url.origin}/api/mcp/search`;
							
							const response = await fetch(apiUrl, {
								method: 'POST',
								headers: {
									'Content-Type': 'application/json',
								},
								body: JSON.stringify(requestBody)
							});

							if (!response.ok) {
								throw new Error(`Search API error: ${response.status}`);
							}

							const data = await response.json();
							const formattedText = formatSearchResultsForMCP(data, query, `Íµ≠Í∞ÄÎ≥Ñ Í≤ÄÏÉâ (${country})`);

							toolResult = {
								content: [{
									type: 'text',
									text: formattedText
								}]
							};
							break;
						}

						case 'get-dataset-info': {
							const { persistent_id, instance_url } = toolArgs || {};
							
							if (!persistent_id) {
								return json({
									jsonrpc: '2.0',
									id: body.id,
									error: {
										code: -32602,
										message: 'Invalid params: persistent_id is required'
									}
								});
							}

							// Í∏∞Ï°¥ APIÎ•º ÏÇ¨Ïö©Ìï¥ÏÑú DOIÎ°ú Í≤ÄÏÉâ
							const requestBody: any = {
								query: persistent_id,
								per_page: 1,
								start: 0,
								sort: 'date',
								order: 'desc'
							};

							// ÌäπÏ†ï Ïù∏Ïä§ÌÑ¥Ïä§ ÏßÄÏ†ï
							if (instance_url) {
								const instance = getActiveInstances().find(inst => inst.url === instance_url);
								if (instance) {
									requestBody.specific_instance = {
										id: instance.id,
										url: instance.url,
										apiUrl: instance.apiUrl,
										platformName: instance.platformName,
										country: instance.country,
										organization: instance.organization
									};
								}
							}

							const url = new URL(request.url);
							const apiUrl = `${url.origin}/api/mcp/search`;
							
							try {
								const response = await fetch(apiUrl, {
									method: 'POST',
									headers: {
										'Content-Type': 'application/json',
									},
									body: JSON.stringify(requestBody)
								});

								if (!response.ok) {
									throw new Error(`Search API error: ${response.status}`);
								}

								const data = await response.json();
								
								if (data.success && data.results && data.results.length > 0) {
									const dataset = data.results[0]; // Ï≤´ Î≤àÏß∏ Í≤∞Í≥º ÏÇ¨Ïö©

									let resultText = `üìä Îç∞Ïù¥ÌÑ∞ÏÖã ÏÉÅÏÑ∏ Ï†ïÎ≥¥\n`;
									resultText += `====================\n\n`;
									resultText += `üÜî **ÏòÅÍµ¨ ID**: ${persistent_id}\n`;
									resultText += `üè∑Ô∏è **Ï†úÎ™©**: ${dataset.title || 'N/A'}\n`;
									
									if (dataset.authors && dataset.authors.length > 0) {
										resultText += `üë§ **Ï†ÄÏûê**: ${dataset.authors.join(', ')}\n`;
									}
									
									if (dataset.description) {
										const desc = dataset.description.length > 200 
											? dataset.description.substring(0, 200) + '...' 
											: dataset.description;
										resultText += `üìù **ÏÑ§Î™Ö**: ${desc}\n`;
									}
									
									if (dataset.publishedAt || dataset.published_at) {
										resultText += `üìÖ **Î∞úÌñâÏùº**: ${new Date(dataset.publishedAt || dataset.published_at).toLocaleDateString('ko-KR')}\n`;
									}
									
									if (dataset.subjects && dataset.subjects.length > 0) {
										resultText += `üè∑Ô∏è **Ï£ºÏ†ú**: ${dataset.subjects.join(', ')}\n`;
									}
									
									if (dataset.instance) {
										resultText += `üèõÔ∏è **Ïù∏Ïä§ÌÑ¥Ïä§**: ${dataset.instance}\n`;
									}
									
									if (dataset.url) {
										resultText += `üîó **URL**: ${dataset.url}\n`;
									}

									toolResult = {
										content: [{
											type: 'text',
											text: resultText
										}]
									};
								} else {
									toolResult = {
										content: [{
											type: 'text',
											text: `Îç∞Ïù¥ÌÑ∞ÏÖã Ï†ïÎ≥¥Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${persistent_id}`
										}]
									};
								}
							} catch (err) {
								const errorMessage = err instanceof Error ? err.message : 'Unknown error';
								toolResult = {
									content: [{
										type: 'text',
										text: `Îç∞Ïù¥ÌÑ∞ÏÖã Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: ${errorMessage}`
									}],
									isError: true
								};
							}
							break;
						}

						case 'list-dataverse-instances': {
							const { country } = toolArgs || {};
							
							const instances = country ? getInstancesByCountry(country) : getActiveInstances();
							const stats = getInstanceStats();
							
							let resultText = `üåç Dataverse Ïù∏Ïä§ÌÑ¥Ïä§ Î™©Î°ù\n`;
							resultText += `============================\n\n`;
							resultText += `üìä ÌÜµÍ≥Ñ:\n`;
							resultText += `‚Ä¢ Ï†ÑÏ≤¥ Ïù∏Ïä§ÌÑ¥Ïä§: ${stats.total}Í∞ú\n`;
							resultText += `‚Ä¢ ÌôúÏÑ± Ïù∏Ïä§ÌÑ¥Ïä§: ${stats.active}Í∞ú\n`;
							resultText += `‚Ä¢ ÏßÄÏõê Íµ≠Í∞Ä: ${stats.countriesCount}Í∞ú\n\n`;
							
							if (country) {
								resultText += `üá∞üá∑ "${country}" Ïù∏Ïä§ÌÑ¥Ïä§ (${instances.length}Í∞ú):\n`;
							} else {
								resultText += `üåê Î™®Îì† ÌôúÏÑ± Ïù∏Ïä§ÌÑ¥Ïä§ (${instances.length}Í∞ú):\n`;
							}
							
							resultText += `${'-'.repeat(50)}\n\n`;
							
							instances.forEach((instance, index) => {
								resultText += `${index + 1}. **${instance.platformName}**\n`;
								resultText += `   üèõÔ∏è Í∏∞Í¥Ä: ${instance.organization}\n`;
								resultText += `   üåç Íµ≠Í∞Ä: ${instance.country}\n`;
								resultText += `   üåê URL: ${instance.url}\n`;
								if (instance.apiUrl) {
									resultText += `   üîó API: ${instance.apiUrl}\n`;
								}
								resultText += `\n`;
							});

							toolResult = {
								content: [{
									type: 'text',
									text: resultText
								}]
							};
							break;
						}

						default:
							return json({
								jsonrpc: '2.0',
								id: body.id,
								error: {
									code: -32601,
									message: `Method not found: ${toolName}`
								}
							});
					}

					return json({
						jsonrpc: '2.0',
						id: body.id,
						result: toolResult
					});

				} catch (err) {
					console.error(`ÎèÑÍµ¨ Ïã§Ìñâ Ïò§Î•ò [${toolName}]:`, err);
					const errorMessage = err instanceof Error ? err.message : 'Unknown error';
					
					return json({
						jsonrpc: '2.0',
						id: body.id,
						error: {
							code: -32603,
							message: `Tool execution failed: ${errorMessage}`
						}
					});
				}
			}

			default:
				return json({
					jsonrpc: '2.0',
					id: body.id || null,
					error: {
						code: -32601,
						message: `Method not found: ${body.method}`
					}
				});
		}

	} catch (err) {
		console.error('MCP ÏÑúÎ≤Ñ Ïò§Î•ò:', err);
		const errorMessage = err instanceof Error ? err.message : 'Unknown error';
		
		return json({
			jsonrpc: '2.0',
			id: body?.id || null,
			error: {
				code: -32603,
				message: `Internal error: ${errorMessage}`
			}
		});
	}
};